package main

import "fmt"

/*
ในการส่งอาร์กิวเมนต์แบบ call by value ค่าของอาร์กิวเมนต์จริงจะถูก copy ไปยังพารามิเตอร์ของฟังก์ชัน โดยอาร์กิวเมนต์จริงและพารามิเตอร์จะถูกเก็บไว้ในหน่วยความจำคนละที่ การเปลี่ยนแปลงค่าของพารามิเตอร์ภายในฟังก์ชันจะไม่ส่งผลต่ออาร์กิวเมนต์จริง

ถึงแม้ว่า Go จะไม่มีการส่งแบบ call by reference เพราะไม่มีตัวแปรแบบ reference แต่เราสามารถส่งที่อยู่ของตัวแปรเข้าไปในฟังก์ชันได้ โดยใช้ตัวดำเนินการ & และ * ร่วมกับ pointer ซึ่งจะทำให้พารามิเตอร์และอาร์กิวเมนต์จริงอ้างอิงไปยังหน่วยความจำตำแหน่งเดียวกัน ทำให้การเปลี่ยนแปลงค่าภายในฟังก์ชันมีผลต่ออาร์กิวเมนต์จริงด้วย
*/

// ตัวอย่างการส่งที่อยู่ของตัวแปรเข้าฟังก์ชัน
// ฟังก์ชัน replace รับพารามิเตอร์ x เป็น pointer ของ int และเปลี่ยนค่าที่ตำแหน่งนั้นเป็น 20
func replace(x *int) {
	*x = 20
}

/* 
ในฟังก์ชัน main ประกาศตัวแปร x และกำหนดค่าเริ่มต้นเป็น 10
แสดงค่า x ก่อนเรียกฟังก์ชัน replace
เรียกฟังก์ชัน replace โดยส่งที่อยู่ของ x เข้าไปด้วย &x
แสดงค่า x หลังเรียกฟังก์ชัน replace
*/

func main() {
	var x int = 10
	fmt.Printf("value of x before function call = %d", x)

	replace(&x)
	fmt.Printf("\nvalue of x after function call = %d", x)
	// จะเห็นว่าค่าของ x เปลี่ยนเป็น 20 เพราะ x และ *x อ้างถึงตำแหน่งเดียวกันในหน่วยความจำ
}